is.simple(g_acq)
# ---
#[1] FALSE
# ---
E(g_acq)$weight
g_acq_simpl<-simplify(g_acq)
E(g_acq_simpl)$weight
# Will use the inverse of log weight for shortest path calculations
inv_weight<-1/log(E(g_acq_simpl)$weight  + 1)
num_weight<-E(g_acq_simpl)$weight
length(inv_weight)
g_acq_simpl$nodes
V(g_acq_simpl)
vertices(g_acq_simpl)
betweenness(g_acq_simpl, v= arr , directed= TRUE, weights = inv_weight, normalized = FALSE, nobigint = TRUE)
df <- as.data.frame(betweenness(g_acq_simpl, v= V(g_acq_simpl) , directed= TRUE, weights = inv_weight, normalized = FALSE, nobigint = TRUE))
df
df[211]
rownames(df)
df$1
df$0
colnames(df) <- c('v', 'value')
df <- as.data.frame(betweenness(g_acq_simpl, v= V(g_acq_simpl) , directed= TRUE, weights = inv_weight, normalized = FALSE, nobigint = TRUE))
colnames(df) <- c('v', 'value')
df <- data.frame(rownames(df), df)
df
colnames(df) <- c('v', 'value')
df[v == 923]
df$v == 923
df[df$v == 923]
df[,df$v == 923]
df
which(df, df$v = 111)
which(df, df$v == 111)
which(df, df$v == '111')
which(df$v == '111')
which(df$v = c('111', '928'))
which(df$v in c('111', '928'))
which(df$v <- c('111', '928'))
df$v == 923
df
df <- as.data.frame(betweenness(g_acq_simpl, v= V(g_acq_simpl) , directed= TRUE, weights = inv_weight, normalized = TRUE, nobigint = TRUE))
df <- data.frame(rownames(df), df)
colnames(df) <- c('v', 'value')
df
shortest_paths(g_acq_simpl, from = "511", to = "523")
?shortest_paths
shortest_paths(g_acq_simpl, to = 523)
shortest_paths(g_acq_simpl, from = 511 ,to = 523)
shortest_paths(g_acq_simpl, from = c(511) ,to = 523)
shortest_paths(g_acq_simpl, from = c(511) ,to = c(523))
shortest_paths(g_acq_simpl, from = v(g_acq_simpl) ,to = c(523))
shortest_paths(g_acq_simpl, from = V(g_acq_simpl) ,to = c(523))
shortest_paths(g_acq_simpl, from = V(g_acq_simpl) ,to = 523)
shortest.paths(g_acq_simpl, v = c(511), to = (523), weights = inv_weight)
shortest.paths(g_acq_simpl, v = c(511), to = c(523), weights = inv_weight)
shortest.paths(g_acq_simpl, v = c(511), to = V(g_acq_simpl), weights = inv_weight)
shortest.paths(g_acq_simpl, to = V(g_acq_simpl), weights = inv_weight)
shortest.paths(g_acq_simpl, to = c(523), weights = inv_weight)
shortest.paths(g_acq_simpl, to = 523, weights = inv_weight)
shortest.paths(g_acq_simpl, 523, weights = inv_weight)
?get_shortest_path
??get_shortest_path
install.packages("rsppfp")
?get_shortest_path
??get_shortest_path
library(rsppfp)
??get_shortest_path
?get_shortest_path
get_shortest_path(g_acq_simpl, "511" , "523" , inv_weight)
get_shortest_path(g_acq_simpl, 511 , 523 , inv_weight)
#shortest.paths(g_acq_simpl, 523, weights = inv_weight)
get.shortest.paths(g_acq_simpl , 5)
shortest.paths(g_acq_simpl, v=c(511), to= V(g_acq_simpl), weights = inv_weight)
shortest.paths(g_acq_simpl,  to= V(g_acq_simpl), weights = inv_weight)
shortest.paths(g_acq_simpl,  to= V(g_acq_simpl)[68], weights = inv_weight)
shortest.paths(g_acq_simpl,  to= V(g_acq_simpl)[68], weights = inv_weight)
shortest.paths(g_acq_simpl,  from= V(g_acq_simpl)[68], weights = inv_weight)
shortest.paths(g_acq_simpl,  v= V(g_acq_simpl)[68], weights = inv_weight)
view(shortest.paths(g_acq_simpl,  v= V(g_acq_simpl)[68], weights = inv_weight))
View(shortest.paths(g_acq_simpl,  v= V(g_acq_simpl)[68], weights = inv_weight))
View(t(shortest.paths(g_acq_simpl,  v= V(g_acq_simpl)[68], weights = inv_weight)))
shortest_paths(g_acq_simpl, from = V(g_acq_simpl)[68], weights = inv_weight)
?shortest_paths
shortest_paths(g_acq_simpl, from = V(g_acq_simpl)[68], to = V(g_acq_simpl)[69] weights = inv_weight)
shortest_paths(g_acq_simpl, from = V(g_acq_simpl)[68], to = V(g_acq_simpl), weights = inv_weight)
shortest_paths(g_acq_simpl, from = V(g_acq_simpl)[68], to = V(g_acq_simpl)[69], weights = inv_weight)
?shortest.paths
distances(g_acq_simpl, v= V(g_acq_simpl)[68], weights = inv_weight)
t(distances(g_acq_simpl, v= V(g_acq_simpl)[68], weights = inv_weight))
t(distances(g_acq_simpl, v= V(g_acq_simpl)[68], weights = inv_weight, mode = "out"))
t(distances(g_acq_simpl, v= V(g_acq_simpl)[68], weights = inv_weight, mode = "in"))
shortest.paths(g_acq_simpl,  to= V(g_acq_simpl)[68], weights = inv_weight, mode = "in")
shortest.paths(g_acq_simpl,  to= V(g_acq_simpl)[68], weights = inv_weight, mode = "out")
# induced subgraph
sub_net<-induced.subgraph(g_acq_simpl, v=c('511', '541',
'518', '519', '517', '325', '423', '446', '512', '523',
'561', '621', '115', '482', '485', '487', '491', '492',
'521', '712' ))
inv_weight_1<-1/log(E(sub_net)$weight  + 1)
diameter(sub_net , weights = inv_weight_1 , directed = T)
diameter(sub_net , weights = inv_weight_1 , directed = F)
?component_distribution
components(g_acq_simpl, mode= c("weak", "strong"))
components(g_acq_simpl, mode= c("strong", "weak"))
weak
components(g_acq_simpl, mode= c("weak", "strong"))
groups(components(g_acq_simpl, mode= c("weak", "strong")))
c <- components(g_acq_simpl, mode= c("weak", "strong"))
component_distribution(g_acq_simpl , mode= c("weak", "strong"))
component_distribution(g_acq_simpl , mode= c("weak", "strong"))$is_connected
components(g_acq_simpl, mode= c("weak", "strong"))
plot(g_acq_simpl)
t <-components(g_acq_simpl, mode= c("weak", "strong"))
count_components(g_acq_simpl, mode= c("weak", "strong"))
count_components(g_acq_simpl, mode= c("strong"))
count_components(g_acq_simpl, mode= c("weak"))
plot(sub_net)
# Edges
ecount(g_acq)
## Vertices
vcount(g_acq)
t <-components(g_acq, mode= c("weak", "strong"))
count_components(g_acq, mode= c("strong"))
# 4 strong
count_components(g_acq, mode= c("weak"))
?plot
V(sub_net)[511]$color<-"red"
V(sub_net)['511']$color<-"red"
#V(sub_net)$color = c("green", "aquamarine", "yellow", "blue", "Red")
plot(sub_net)
V(sub_net)[c('511', '541', '518', '519')]$color<-c("red", "blue", "yellow", "aquamarine")
#V(sub_net)$color = c("green", "aquamarine", "yellow", "blue", "Red")
plot(sub_net)
E(sub_net)$weight <- inv_weight_1
plot(sub_net)
plot(sub_net)
V(sub_net)$size
plot(sub_net, vertex.size = inv_weight_1)
plot(sub_net)
plot(sub_net, vertex.size= degree(g)*0.5, main="Degree Centrality")
plot(sub_net, vertex.size= degree(sub_net)*0.5, main="Degree Centrality")
plot(sub_net, vertex.size= degree(sub_net)*1.5, main="Degree Centrality")
plot(sub_net, vertex.size= degree(sub_net)*1.2, main="Degree Centrality")
plot(sub_net, vertex.size= degree(sub_net)*1.2, main="Degree Centrality", layout=layout.fruchterman.reingold)
plot(sub_net, vertex.size= degree(sub_net)*1.2,
layout=layout.fruchterman.reingold, color = ategorical_pal(8))
plot(sub_net, vertex.size= degree(sub_net)*1.2,
layout=layout.fruchterman.reingold, color = categorical_pal(8))
V(sub_net)[c('511', '541', '518', '519')]$color<-c("red", "lightblue", "yellow", "aquamarine")
E(sub_net)$weight <- inv_weight_1
plot(sub_net, vertex.size= degree(sub_net)*1.2,
layout=layout.fruchterman.reingold)
title("HW_2 Graph")
plot(sub_net, vertex.size= degree(sub_net)*0.9,
layout=layout.fruchterman.reingold)
title("HW_2 Graph")
diameter(g_acq_simpl , weights = inv_weight , directed = T)
diameter(g_acq_simpl , weights = inv_weight , directed = F)
df <- as.data.frame(betweenness(g_acq_simpl, v= V(g_acq_simpl) , directed= TRUE, weights = inv_weight, normalized = TRUE, nobigint = TRUE))
View(df)
shortest.paths(g_acq_simpl,  to= V(g_acq_simpl)[68], weights = inv_weight, mode = "in")
?closeness
closeness(g_acq_simpl, vids = V(g_acq_simpl), mode = "out", weights = inv_weight)
closeness(g_acq_simpl, vids = V(g_acq_simpl), mode = "out", weights = inv_weight, normalized = TRUE)
closeness(g_acq_simpl, vids = V(g_acq_simpl), mode = "in", weights = inv_weight, normalized = TRUE)
closeness(g_acq_simpl, vids = V(g_acq_simpl), mode = "in", weights = inv_weight, normalized = FALSE)
#Read in the hs0 data over the internet using the read.table() function.
#getwd()
# Save the data file to a location on your hard drive and specify the path here (Windows systems use forward slashes)
#dir_path <-"~/YourWorkingDirectoryFilePath"
#setwd(dir_path)
# clear everything out of memory
#rm(list=ls())
infile<-"~/Downloads/SPRING 2020/Social Media and Analysis - IDS 564/Lab-2/MergerNet_Jan21_2016_forR.csv"
## Load package
library(igraph)
el=read.csv(infile, header = TRUE, sep = ",")
g_acq=graph.data.frame(el, directed = TRUE, vertices= NULL)
### List of all the years represented in the set
el[,"year"]
df <-data.frame(el)
class(df$weight)
class(df$source)
class(el)
# Edges
ecount(g_acq)
## Vertices
vcount(g_acq)
t <-components(g_acq, mode= c("weak", "strong"))
count_components(g_acq, mode= c("strong"))
# 4 strong
count_components(g_acq, mode= c("weak"))
#Is it a simple graph? No!
## Check whether Self_loops exist, as do multiple edges
is.simple(g_acq)
# ---
#[1] FALSE
# ---
E(g_acq)$weight
g_acq_simpl<-simplify(g_acq)
E(g_acq_simpl)$weight
# Will use the inverse of log weight for shortest path calculations
inv_weight<-1/log(E(g_acq_simpl)$weight  + 1)
num_weight<-E(g_acq_simpl)$weight
length(inv_weight)
diameter(g_acq_simpl , weights = inv_weight , directed = T)
diameter(g_acq_simpl , weights = inv_weight , directed = F)
df <- as.data.frame(betweenness(g_acq_simpl, v= V(g_acq_simpl) , directed= TRUE, weights = inv_weight, normalized = TRUE, nobigint = TRUE))
View(df)
closeness(g_acq_simpl, vids = V(g_acq_simpl), mode = "in", weights = inv_weight, normalized = FALSE)
closeness(g_acq_scc, vids = V(g_acq_scc), mode = "in", weights = inv_weight)
# Remove disconnected components to create a strongly connected component.
#We will use this component to calculate closeness and shortest path distances.
g_acq_scc <-g_acq_simpl - vertices('814', '925', '928')
inv_weight_scc<-1/log(E(g_acq_scc)$weight  + 1)
closeness(g_acq_scc, vids = V(g_acq_scc), mode = "in", weights = inv_weight)
closeness(g_acq_scc, vids = V(g_acq_scc), mode = "in", weights = inv_weight_scc)
?transitivity
transitivity(g_acq_simpl, type = "local", weights = inv_weight)
transitivity(g_acq_simpl, type = "global", weights = inv_weight)
mean_loc <- mean(loc)
loc <- transitivity(g_acq_simpl, type = "local", weights = inv_weight)
mean_loc <- mean(loc)
sd_loc <- sd(loc)
mean_loc
sd_loc
loc <- transitivity(g_acq_simpl, type = "local", weights = inv_weight)
mean_loc <- mean(loc)
sd_loc <- sd(loc)
mean_loc
?mean
mean_loc <- mean(loc, na.rm = TRUE)
mean_loc
sd_loc <- sd(loc)
sd_loc
?sd
sd_loc <- sd(loc, na.rm = TRUE)
sd_loc
getwd()
# Save the data file to a location on your hard drive and specify the path here (Windows systems use forward slashes)
dir_path <-'/Users/pawanjeetkaur/Downloads/SPRING 2020/Social Media and Analysis - IDS 564/Lab-3'
setwd(dir_path)
# clear everything out of memory
rm(list=ls())
# Load primary school data, contact data
infile_edges<-"Edges_sp_data_school_day_2.csv"
infile_nodes<-"Nodes_sp_data_school_day_2.csv"
## Load package
library(igraph)
edge_frame=read.csv(infile_edges, header = TRUE, sep = ",")
node_frame=read.csv(infile_nodes, header = TRUE, sep = ",")
g_primschool=graph.data.frame(edge_frame, directed = FALSE, vertices= node_frame)
# Edges
ecount(g_primschool)
## Vertices
vcount(g_primschool)
is.weighted(g_primschool)
V(g_primschool)$name
E(g_primschool)$weight
V(g_primschool)$gender
V(g_primschool)[V(g_primschool)$classname=="1B"]
is.simple(g_primschool)
is.connected(g_primschool)
# http://igraph.wikidot.com/community-detection-in-r
# "The following code snippet performs a Wilcoxon rank-sum test on the "internal" and "external"
# degrees of a community in order to quantify its significance. Let us call the edges within a
# community "internal" and the edges connecting the vertices of a community with the rest of the graph "external".
# The null hypothesis of the test is that there is no difference between the number of "internal" and "external" edges
# incident to a vertex of the community. More internal than external edges show that the community is significant; less
# internal than external edges show that the community is in fact an "anti-community". The p-value of the test performed by
# this function will be close to zero in both cases; the value of the test statistic tells us whether we have a community or an anti-community."
community.significance.test <- function(graph, vs, ...) {
if (is.directed(graph)) stop("This method requires an undirected graph")
subgraph <- induced.subgraph(graph, vs)
in.degrees <- degree(subgraph)
# Total degree among nodes in the vs list, minus the degree within the subgraph
out.degrees <- degree(graph, vs) - in.degrees
wilcox.test(in.degrees, out.degrees, ...)
}
stud.class <- get.vertex.attribute(g_primschool, "classname")
stud.gender<- get.vertex.attribute(g_primschool, "gender")
# Community detection using the Fast Greedy Algorithm
school_comm_fast <- fastgreedy.community(g_primschool, weights=E(g_primschool)$weight)
c.m <- membership(school_comm_fast)
# Assignment to communities, based on class section or teacher status. This analysis can be extended to gender (see below).
table(c.m, stud.class, useNA = c("no"))
# walktrap :
school_comm_walk <- walktrap.community(g_primschool, weights=E(g_primschool)$weight)
c.m_1 <- membership(school_comm_walk)
table(c.m_1, stud.class, useNA = c("no"))
#springlass
school_comm_sping <- spinglass.community(g_primschool, weights=E(g_primschool)$weight)
c.m_2 <- membership(school_comm_sping)
table(c.m_2, stud.class, useNA = c("no"))
#label prop
school_comm_label = cluster_label_prop(g_primschool, weights = E(g_primschool)$weight)
c.m_3 <- membership(school_comm_label)
table(c.m_3, stud.class, useNA = c("no"))
# Here, we are testing community significance for just two of the communities. Students will complete tests for the remainder of communities for each algorithm.
v_comp1 <- V(g_primschool)[c.m==1]
v_comp2 <- V(g_primschool)[c.m==2]
community.significance.test(g_primschool, v_comp1)
community.significance.test(g_primschool, v_comp2)
# Students will produce similar plots for the walktrap, spinglass, and label propagation algorithms for community detection
plot(school_comm_fast,g_primschool, vertex.label= NA, vertex.size=2)
# Consider students in first grade and 5th grade. To what extent does community structure indicate that students segregate by gender in these two grades?
# Use the Fast Greedy algorithm for analysis.
v_grade1students<-V(g_primschool)[V(g_primschool)$classname=="1B" | V(g_primschool)$classname=="1A"]
v_grade5students<-V(g_primschool)[V(g_primschool)$classname=="5B" | V(g_primschool)$classname=="5A"]
subgraph_grade1<-induced_subgraph(g_primschool, v_grade1students)
subgraph_grade5<-induced_subgraph(g_primschool, v_grade5students)
stud.gender_1 = stud.gender[stud.class == "1B" | stud.class == "1A"]
stud.class_1 = stud.class[stud.class == "1B" | stud.class == "1A"]
stud.gender_2 = stud.gender[stud.class == "5B" | stud.class == "5A"]
stud.class_2 = stud.class[stud.class == "5B" | stud.class == "5A"]
school_comm_grade_1 <- fastgreedy.community(subgraph_grade1, weights=E(subgraph_grade1)$weight)
c.m_4 <- membership(school_comm_grade_1)
table(c.m_4, stud.gender_1, stud.class_1, useNA = c("no"))
table(c.m_4, stud.gender_1, useNA = c("no"))
table(c.m_5, stud.gender_2, useNA = c("no"))
school_comm_grade_2 <- fastgreedy.community(subgraph_grade5, weights=E(g_primschool)$weight)
c.m_5 <- membership(school_comm_grade_2)
table(c.m_5, stud.gender_2, stud.class_2,  useNA = c("no"))
g <- graph.formula(A-B,B-C,C-D, D-E, E-A)
E(g)$sign<-c(+1,-1, -1, +1, 1)
plot(g)
g <- graph.formula(A-B,A-C,A-D, B-C, B-D, C-D )
E(g)$sign<-c(+1,1, -1, 1, -1, 1)
plot(g)
table(c.m_3, stud.class, useNA = c("no"))
#label prop
school_comm_label = cluster_label_prop(g_primschool, weights = E(g_primschool)$weight)
c.m_3 <- membership(school_comm_label)
table(c.m_3, stud.class, useNA = c("no"))
table(c.m_1, stud.class, useNA = c("no"))
# walktrap :
school_comm_walk <- walktrap.community(g_primschool, weights=E(g_primschool)$weight)
c.m_1 <- membership(school_comm_walk)
table(c.m_1, stud.class, useNA = c("no"))
# walktrap :
school_comm_walk <- walktrap.community(g_primschool, weights=E(g_primschool)$weight)
c.m_1 <- membership(school_comm_walk)
table(c.m_1, stud.class, useNA = c("no"))
# Assignment to communities, based on class section or teacher status. This analysis can be extended to gender (see below).
table(c.m, stud.class, useNA = c("no"))
# Community detection using the Fast Greedy Algorithm
school_comm_fast <- fastgreedy.community(g_primschool, weights=E(g_primschool)$weight)
c.m <- membership(school_comm_fast)
# Assignment to communities, based on class section or teacher status. This analysis can be extended to gender (see below).
table(c.m, stud.class, useNA = c("no"))
v_grade1students<-V(g_primschool)[V(g_primschool)$classname=="1B" | V(g_primschool)$classname=="1A"]
v_grade5students<-V(g_primschool)[V(g_primschool)$classname=="5B" | V(g_primschool)$classname=="5A"]
subg_grade1<-induced_subgraph(g_primschool, v_grade1students)
stud.gender1<- get.vertex.attribute(subg_grade1, "gender")
subg_grade5<-induced_subgraph(g_primschool, v_grade5students)
stud.gender5<- get.vertex.attribute(subg_grade5, "gender")
school_comm_fast_sub1 <- fastgreedy.community(subg_grade1, weights=E(subg_grade1)$weight)
c.m.sub1 <- membership(school_comm_fast_sub1)
table(c.m.sub1, stud.gender1, useNA = c("no"))
plot(school_comm_fast_sub1, subg_grade1, vertex.label= NA, vertex.size=2)
l
l
school_comm_fast_sub5 <- fastgreedy.community(subg_grade5, weights=E(subg_grade5)$weight)
c.m.sub5 <- membership(school_comm_fast_sub5)
table(c.m.sub5, stud.gender5, useNA = c("no"))
plot(school_comm_fast_sub5, subg_grade5, vertex.label= NA, vertex.size=2)
v_grade1Astudents<-V(g_primschool)[V(g_primschool)$classname=="1A"]
v_grade1Bstudents<-V(g_primschool)[V(g_primschool)$classname=="1B"]
subg_grade1A<-induced_subgraph(g_primschool, v_grade1Astudents)
subg_grade1B<-induced_subgraph(g_primschool, v_grade1Bstudents)
stud.gender1A<- get.vertex.attribute(subg_grade1A, "gender")
stud.gender1B<- get.vertex.attribute(subg_grade1B, "gender")
school_comm_fast_sub1A <- fastgreedy.community(subg_grade1A, weights=E(subg_grade1A)$weight)
school_comm_fast_sub1B <- fastgreedy.community(subg_grade1B, weights=E(subg_grade1B)$weight)
c.m.sub1A <- membership(school_comm_fast_sub1A)
c.m.sub1B <- membership(school_comm_fast_sub1B)
table(c.m.sub1A, stud.gender1A, useNA = c("no"))
table(c.m.sub1B, stud.gender1B, useNA = c("no"))
#plot for fastgreedy algorithm
plot(school_comm_fast,g_primschool, vertex.label= NA, vertex.size=3) + title(main = "Fast Greedy Algorithm")
getwd()
# Save the data file to a location on your hard drive and specify the path here (Windows systems use forward slashes)
dir_path <-'/Users/pawanjeetkaur/Downloads/SPRING 2020/Social Media and Analysis - IDS 564/Lab-3'
setwd(dir_path)
# clear everything out of memory
rm(list=ls())
# Load primary school data, contact data
infile_edges<-"Edges_sp_data_school_day_2.csv"
infile_nodes<-"Nodes_sp_data_school_day_2.csv"
## Load package
library(igraph)
edge_frame=read.csv(infile_edges, header = TRUE, sep = ",")
node_frame=read.csv(infile_nodes, header = TRUE, sep = ",")
g_primschool=graph.data.frame(edge_frame, directed = FALSE, vertices= node_frame)
# Edges
ecount(g_primschool)
## Vertices
vcount(g_primschool)
is.weighted(g_primschool)
V(g_primschool)$name
E(g_primschool)$weight
V(g_primschool)$gender
V(g_primschool)[V(g_primschool)$classname=="1B"]
is.simple(g_primschool)
is.connected(g_primschool)
# http://igraph.wikidot.com/community-detection-in-r
# "The following code snippet performs a Wilcoxon rank-sum test on the "internal" and "external"
# degrees of a community in order to quantify its significance. Let us call the edges within a
# community "internal" and the edges connecting the vertices of a community with the rest of the graph "external".
# The null hypothesis of the test is that there is no difference between the number of "internal" and "external" edges
# incident to a vertex of the community. More internal than external edges show that the community is significant; less
# internal than external edges show that the community is in fact an "anti-community". The p-value of the test performed by
# this function will be close to zero in both cases; the value of the test statistic tells us whether we have a community or an anti-community."
community.significance.test <- function(graph, vs, ...) {
if (is.directed(graph)) stop("This method requires an undirected graph")
subgraph <- induced.subgraph(graph, vs)
in.degrees <- degree(subgraph)
# Total degree among nodes in the vs list, minus the degree within the subgraph
out.degrees <- degree(graph, vs) - in.degrees
wilcox.test(in.degrees, out.degrees, ...)
}
stud.class <- get.vertex.attribute(g_primschool, "classname")
stud.gender<- get.vertex.attribute(g_primschool, "gender")
# Community detection using the Fast Greedy Algorithm
school_comm_fast <- fastgreedy.community(g_primschool, weights=E(g_primschool)$weight)
c.m <- membership(school_comm_fast)
# Assignment to communities, based on class section or teacher status. This analysis can be extended to gender (see below).
table(c.m, stud.class, useNA = c("no"))
# Here, we are testing community significance in fast greedy.
v_comp1 <- V(g_primschool)[c.m==1]
v_comp2 <- V(g_primschool)[c.m==2]
v_comp3 <- V(g_primschool)[c.m==3]
v_comp4 <- V(g_primschool)[c.m==4]
v_comp5 <- V(g_primschool)[c.m==5]
v_comp6 <- V(g_primschool)[c.m==6]
v_comp7 <- V(g_primschool)[c.m==7]
community.significance.test(g_primschool, v_comp1)
#significant
community.significance.test(g_primschool, v_comp2)
#not-significant
community.significance.test(g_primschool, v_comp3)
#significant
community.significance.test(g_primschool, v_comp4)
#not-significant
community.significance.test(g_primschool, v_comp5)
#significant
community.significance.test(g_primschool, v_comp6)
#not-significant
community.significance.test(g_primschool, v_comp7)
#plot for fastgreedy algorithm
plot(school_comm_fast,g_primschool, vertex.label= NA, vertex.size=3) + title(main = "Fast Greedy Algorithm")
# walktrap :
school_comm_walk <- walktrap.community(g_primschool, weights=E(g_primschool)$weight)
c.m_1 <- membership(school_comm_walk)
table(c.m_1, stud.class, useNA = c("no"))
v_walk_comp1 <- V(g_primschool)[c.m_1==1]
v_walk_comp2 <- V(g_primschool)[c.m_1==2]
v_walk_comp3 <- V(g_primschool)[c.m_1==3]
v_walk_comp4 <- V(g_primschool)[c.m_1==4]
v_walk_comp5 <- V(g_primschool)[c.m_1==5]
v_walk_comp6 <- V(g_primschool)[c.m_1==6]
v_walk_comp7 <- V(g_primschool)[c.m_1==7]
v_walk_comp8 <- V(g_primschool)[c.m_1==8]
v_walk_comp9 <- V(g_primschool)[c.m_1==9]
community.significance.test(g_primschool, v_walk_comp1)
#significant
community.significance.test(g_primschool, v_walk_comp2)
#significant
community.significance.test(g_primschool, v_walk_comp3)
#not-significant
community.significance.test(g_primschool, v_walk_comp4)
#not-significant
community.significance.test(g_primschool, v_walk_comp5)
#not-significant
community.significance.test(g_primschool, v_walk_comp6)
#not-significant
community.significance.test(g_primschool, v_walk_comp7)
#not-significant
community.significance.test(g_primschool, v_walk_comp8)
#not-significant
community.significance.test(g_primschool, v_walk_comp9)
plot(school_comm_walk,g_primschool, vertex.label= NA, vertex.size=3) + title(main = "Walktrap Algorithm")
#springlass
school_comm_sping <- spinglass.community(g_primschool, weights=E(g_primschool)$weight)
c.m_2 <- membership(school_comm_sping)
table(c.m_2, stud.class, useNA = c("no"))
plot(school_comm_sping, g_primschool, vertex.label= NA, vertex.size=1) + title(main = "Spinglass Algorithm")
#label prop
school_comm_label = cluster_label_prop(g_primschool, weights = E(g_primschool)$weight)
c.m_3 <- membership(school_comm_label)
table(c.m_3, stud.class, useNA = c("no"))
plot(school_comm_label, g_primschool, vertex.label= NA, vertex.size=1) + title(main = "Spinglass Algorithm")
# Here, we are testing community significance for just two of the communities. Students will complete tests for the remainder of communities for each algorithm.
v_comp1 <- V(g_primschool)[c.m==1]
v_comp2 <- V(g_primschool)[c.m==2]
community.significance.test(g_primschool, v_comp1)
community.significance.test(g_primschool, v_comp2)
# Students will produce similar plots for the walktrap, spinglass, and label propagation algorithms for community detection
plot(school_comm_fast,g_primschool, vertex.label= NA, vertex.size=2)
# Girvan Newman
school_comm_edge <- edge.betweenness.community(g_primschool, weights=E(g_primschool)$weight)
Girvan_size <- sizes(school_comm_edge)
c.m.edge <- membership(school_comm_edge)
table(c.m.edge, stud.class, useNA = c("no"))
table(c.m.edge, stud.gender, useNA = c("no"))
plot(school_comm_edge, g_primschool, vertex.edge= NA, vertex.size=1)+ title(main = "Girvan Newman Algorithm")
#plot for fastgreedy algorithm
plot(school_comm_fast,g_primschool, vertex.label= NA, vertex.size=3) + title(main = "Fast Greedy Algorithm")
plot(school_comm_walk,g_primschool, vertex.label= NA, vertex.size=3) + title(main = "Walktrap Algorithm")
plot(school_comm_sping, g_primschool, vertex.label= NA, vertex.size=1) + title(main = "Spinglass Algorithm")
plot(school_comm_label, g_primschool, vertex.label= NA, vertex.size=1) + title(main = "Label-Propagation Algorithm")
